{"name":"Reactive Messaging Patterns with F# and Akka.NET","tagline":"F# examples for the Reactive Messaging Patterns with the Actor Model book by Vaughn Vernon","body":"#Reactive Messaging Patterns with F# and Akka.NET\r\n\r\nRecently I've been reading the Reactive Messaging Patterns with the Actor Model book by Vaughn Vernon. This is a good book that applies the patterns described in the classic Enterprise Integration Patterns book using the Scala language and the Akka framework (Actor Model).\r\n\r\nAs I am an F# fan, I thought it would be a good exercise to translate the examples to F# and Akka.net. If you know F# and Akka.net (or want to learn), I encourage you to read the book and follow the examples I share here. Bear in mind that I won't cover in detail each pattern, I will just provide a short description and its F#/Akka.net example, for more details please refer to the book.\r\n\r\nThe first 3 chapters of the book are basically about introducing Actor Model, Akka and Scala. The catalogue really starts in chapter 4, so this first post is about the patterns described in that chapter.\r\n\r\n##Intro to Akka.net's F# API\r\n\r\nBefore we start, it is worth mentioning that Akka.net's F# API allows you to create actors in different ways, the simplest one allows you to do it in just one line of code!\r\n\r\n```fsharp\r\nlet actorRef = spawn system \"myActor\" (actorOf (fun msg -> (* Handle message here *) () ))\r\n```\r\n\r\nAlthough that is very impressive, the truth is that sometimes you will need more control over the way the actor is created and how it interacts with Akka.net. So, to keep all the examples consistent I chose to use a more advanced technique, the \"actor\" computation expression:\r\n\r\n```fsharp\r\nlet actor (mailbox: Actor<_>) = \r\n    let rec loop () = actor {\r\n        let! message = mailbox.Receive ()\r\n        // Handle message here\r\n        return! loop ()\r\n    }\r\n    loop ()\r\n```\r\n\r\nlet actorRef = spawn system \"myActor\" actor\r\n\r\nAlthough this second option is more verbose, it is also more powerful as you have access to the mailbox and you can control the actor's workflow (you will see in future examples).\r\n\r\nAs you can appreciate, an actor in F# is a function that:\r\n\t- Receives a mailbox as parameter\r\n\t- Returns an actor computation expression\r\n\r\nThe mailbox's type is Actor<'a>, where 'a is the type of message. In most of the cases you can leave it as Actor<_> as the F# compiler will infer the type for you.\r\n\r\nThe returned type, the actor computation expression, is implemented using a self-invoking recursive function. Its first line \"let! message = mailbox.Receive ()\" is receiving the message sent to the actor. if no message is available yet, the actor will be blocked until a message arrives. After the message is received and handled, the line \"return! Loop ()\" invokes the loop again to wait for the next message. The last line executes the loop function for the first time to initiate the actor. \r\n\r\nDon't worry if you couldn't follow the code for the first time, it took me a while to get my mind around. I recommend you to write a few actors to fully understand how it works.\r\n\r\nOnce you create an actor, you have a reference to it, so now you can send messages to it in this way:\r\n\r\n```fsharp\r\nactorRef <! \"message\"\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}